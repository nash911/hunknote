#!/usr/bin/env python
"""
Compose Checkpoint Test Runner

Tests each commit checkpoint from a Compose plan by running the full test suite
at each checkpoint to verify that every intermediate commit leaves the codebase
in a valid state.

Usage:
    python scripts/test_compose_checkpoints.py [commit_hash]

If no commit hash is provided, the most recent commit on the current branch
is used as the starting point.

The script finds all contiguous commits that are 1 second apart in their
author timestamps (the signature of commits generated by `hunknote compose`),
checks out each one in chronological order, runs the test suite, and reports
pass/fail for each checkpoint.
"""

from __future__ import annotations

import argparse
import subprocess
import sys
import time
from dataclasses import dataclass, field
from pathlib import Path


# ── Terminal formatting ──────────────────────────────────────────────────────

class _Ansi:
    """Callable ANSI wrapper: wraps text with an escape code and reset."""

    _RESET = "\033[0m"

    def __init__(self, code: str) -> None:
        self._code = code

    def __call__(self, text: str) -> str:
        return f"{self._code}{text}{self._RESET}"


# Reusable style instances
class Style:
    RED = _Ansi("\033[0;31m")
    GREEN = _Ansi("\033[0;32m")
    YELLOW = _Ansi("\033[1;33m")
    CYAN = _Ansi("\033[0;36m")
    DIM = _Ansi("\033[2m")
    BOLD = _Ansi("\033[1m")


def _log(icon: str, message: str) -> None:
    print(f"  {icon}  {message}")


def log_info(message: str) -> None:
    _log(Style.CYAN("●"), message)


def log_pass(message: str) -> None:
    _log(Style.GREEN("✓"), message)


def log_fail(message: str) -> None:
    _log(Style.RED("✗"), message)


def log_warn(message: str) -> None:
    _log(Style.YELLOW("!"), message)


def heading(title: str, width: int = 64) -> None:
    """Print a centered section heading."""
    print()
    print(Style.DIM(f"  {'─' * width}"))
    padding = (width - len(title)) // 2
    print(Style.BOLD(f"  {' ' * padding}{title}"))
    print(Style.DIM(f"  {'─' * width}"))
    print()


def subheading(title: str) -> None:
    """Print a left-aligned sub-heading."""
    print(f"  {Style.BOLD(title)}")
    print()


def _truncate(text: str, max_len: int) -> str:
    """Truncate text to max_len, appending '...' if shortened."""
    if len(text) <= max_len:
        return text
    return text[: max_len - 3] + "..."


# ── Data classes ─────────────────────────────────────────────────────────────

@dataclass
class CommitInfo:
    """Information about a single commit."""
    short_hash: str
    full_hash: str
    timestamp: int
    timestamp_human: str
    message: str

    def oneline(self, max_msg: int = 55) -> str:
        msg = _truncate(self.message, max_msg)
        return f"{Style.DIM(self.short_hash)}  {msg}"


@dataclass
class CheckpointResult:
    """Result of running tests at a single checkpoint."""
    commit: CommitInfo
    index: int
    passed: bool
    summary_line: str
    failed_tests: list[str] = field(default_factory=list)
    duration_seconds: float = 0.0
    output_file: str = ""


# ── Git helpers ──────────────────────────────────────────────────────────────

def git(*args: str, check: bool = True) -> str:
    """Run a git command and return stripped stdout."""
    result = subprocess.run(
        ["git", *args],
        capture_output=True,
        text=True,
        check=check,
    )
    return result.stdout.strip()


def has_uncommitted_changes() -> bool:
    """Check if the working tree has staged or unstaged changes."""
    try:
        subprocess.run(["git", "diff", "--quiet"], check=True, capture_output=True)
        subprocess.run(["git", "diff", "--cached", "--quiet"], check=True, capture_output=True)
        return False
    except subprocess.CalledProcessError:
        return True


def resolve_commit(ref: str) -> str:
    """Resolve a ref to a full commit hash, or exit if invalid."""
    try:
        return git("rev-parse", ref)
    except subprocess.CalledProcessError:
        log_fail(f"Commit '{ref}' does not exist.")
        sys.exit(1)


def get_commit_info(full_hash: str) -> CommitInfo:
    """Build a CommitInfo from a full hash."""
    return CommitInfo(
        short_hash=git("rev-parse", "--short", full_hash),
        full_hash=full_hash,
        timestamp=int(git("log", "-1", "--format=%at", full_hash)),
        timestamp_human=git("log", "-1", "--format=%ai", full_hash),
        message=git("log", "-1", "--format=%s", full_hash),
    )


def get_parent_hash(full_hash: str) -> str | None:
    """Return the first parent hash, or None for root commits."""
    try:
        parent = git("log", "-1", "--format=%H", f"{full_hash}^")
        return parent or None
    except subprocess.CalledProcessError:
        return None


def get_current_ref() -> str:
    """Return the current branch name, or short hash if detached."""
    try:
        return git("symbolic-ref", "--short", "HEAD")
    except subprocess.CalledProcessError:
        return git("rev-parse", "--short", "HEAD")


def checkout(ref: str) -> None:
    """Silently check out a ref."""
    subprocess.run(
        ["git", "checkout", "--quiet", ref],
        capture_output=True,
        check=True,
    )


# ── Compose group discovery ─────────────────────────────────────────────────

def find_compose_group(starting_hash: str) -> list[CommitInfo]:
    """Find all contiguous commits whose timestamps differ by ≤2 seconds.

    Walks backward (parents) and forward (children) from the starting
    commit, collecting neighbors that are within the compose-plan
    timestamp window.

    Returns commits sorted chronologically (oldest first).
    """
    start_info = get_commit_info(starting_hash)
    group: dict[str, CommitInfo] = {starting_hash: start_info}

    # Walk backward
    current, current_ts = starting_hash, start_info.timestamp
    while True:
        parent = get_parent_hash(current)
        if not parent:
            break
        parent_ts = int(git("log", "-1", "--format=%at", parent))
        if abs(current_ts - parent_ts) <= 2:
            group[parent] = get_commit_info(parent)
            current, current_ts = parent, parent_ts
        else:
            break

    # Walk forward
    current, current_ts = starting_hash, start_info.timestamp
    while True:
        try:
            lines = git(
                "log", "--all", "--format=%H %at", "--reverse",
                "--ancestry-path", f"{current}..HEAD",
            )
        except subprocess.CalledProcessError:
            break

        if not lines:
            break

        found = False
        for line in lines.split("\n"):
            parts = line.strip().split()
            if len(parts) < 2:
                continue
            child_hash, child_ts = parts[0], int(parts[1])

            if child_hash in group:
                continue

            try:
                first_parent = git("log", "-1", "--format=%P", child_hash).split()[0]
            except (subprocess.CalledProcessError, IndexError):
                continue

            if first_parent == current and abs(child_ts - current_ts) <= 2:
                group[child_hash] = get_commit_info(child_hash)
                current, current_ts = child_hash, child_ts
                found = True
                break

        if not found:
            break

    return sorted(group.values(), key=lambda c: c.timestamp)


# ── Test runner ──────────────────────────────────────────────────────────────

def run_tests_at_checkpoint(
    commit: CommitInfo,
    index: int,
    total: int,
    output_dir: Path,
) -> CheckpointResult:
    """Check out a commit and run the full test suite."""
    label = f"C{index}/{total}"
    print(f"  {Style.DIM('[')} {Style.BOLD(label)} {Style.DIM(']')}  "
          f"{commit.oneline()}")

    checkout(commit.full_hash)

    output_file = output_dir / f"_checkpoint_test_c{index}.txt"
    t0 = time.time()
    proc = subprocess.run(
        [sys.executable, "-m", "pytest", "tests/", "-q", "--tb=line"],
        capture_output=True,
        text=True,
    )
    duration = time.time() - t0

    full_output = proc.stdout + proc.stderr
    output_file.write_text(full_output)

    # Last non-empty line is the pytest summary
    out_lines = [l for l in full_output.strip().splitlines() if l.strip()]
    summary_line = out_lines[-1] if out_lines else "(no output)"

    # Collect FAILED and ERROR lines
    failed_tests = [
        l.strip() for l in full_output.splitlines()
        if l.strip().startswith(("FAILED ", "ERROR "))
    ]

    passed = proc.returncode == 0

    status = Style.GREEN("PASS") if passed else Style.RED("FAIL")
    duration_str = Style.DIM(f"{duration:.1f}s")

    print(f"         {status}  {summary_line}  {duration_str}")

    if not passed and failed_tests:
        for ft in failed_tests:
            print(f"           {Style.RED('│')} {ft}")

    print()
    return CheckpointResult(
        commit=commit,
        index=index,
        passed=passed,
        summary_line=summary_line,
        failed_tests=failed_tests,
        duration_seconds=round(duration, 2),
        output_file=str(output_file),
    )


# ── Report ───────────────────────────────────────────────────────────────────

def print_report(
    group: list[CommitInfo],
    results: list[CheckpointResult],
) -> None:
    """Print the final checkpoint test report."""
    total = len(results)
    total_pass = sum(r.passed for r in results)
    total_fail = total - total_pass
    total_duration = sum(r.duration_seconds for r in results)

    heading("Checkpoint Test Report")

    # Metadata
    print(f"  {'Commits:':<14} {total}")
    print(f"  {'Range:':<14} {group[0].timestamp_human}  →  {group[-1].timestamp_human}")
    print(f"  {'Duration:':<14} {total_duration:.1f}s")
    print()

    # Results table
    hdr = f"  {'#':<5}  {'Hash':<9}  {'Status':<6}  {'Time':>6}  Message"
    print(Style.DIM(hdr))
    print(Style.DIM(f"  {'─' * 5}  {'─' * 9}  {'─' * 6}  {'─' * 6}  {'─' * 50}"))

    for r in results:
        status = Style.GREEN("PASS") if r.passed else Style.RED("FAIL")
        idx = f"C{r.index}"
        hash_col = Style.DIM(f"{r.commit.short_hash:<9}")
        msg = _truncate(r.commit.message, 50)
        print(f"  {idx:<5}  {hash_col}  {status}    {r.duration_seconds:>5.1f}s  {msg}")

    # Totals
    print()
    if total_fail == 0:
        log_pass(f"All {total} checkpoints passed")
    else:
        log_fail(f"{total_fail}/{total} checkpoints failed")

    # Broken checkpoint details
    if total_fail > 0:
        print()
        subheading("Broken Checkpoints")
        print("  These commits have failing tests, suggesting the compose plan")
        print("  split causally dependent changes across separate commits:")
        print()

        for r in results:
            if r.passed:
                continue
            print(f"  {Style.RED(f'C{r.index}')}  {Style.DIM(r.commit.short_hash)}  "
                  f"{r.commit.message}")
            errors = r.failed_tests or [r.summary_line]
            for e in errors:
                print(f"      {Style.DIM('└')} {e}")
            print()

        print(f"  {Style.DIM('Logs:')}  temp/_checkpoint_test_c*.txt")

    print()


# ── Entry point ──────────────────────────────────────────────────────────────

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Test each commit checkpoint from a Compose plan.",
        epilog=(
            "If no commit hash is provided, the most recent commit on the "
            "current branch is used. The script finds contiguous commits "
            "that are ≤2 seconds apart (the signature of hunknote compose), "
            "checks out each one, and runs the test suite."
        ),
    )
    parser.add_argument(
        "commit",
        nargs="?",
        default=None,
        help="Starting commit hash (default: HEAD)",
    )
    args = parser.parse_args()

    heading("Compose Checkpoint Test Runner")

    # ── Pre-flight ───────────────────────────────────────────────
    if has_uncommitted_changes():
        log_warn("Uncommitted changes detected in the working tree.")
        print()
        print("  This script checks out different commits to run tests,")
        print("  which conflicts with uncommitted changes.")
        print()
        print(f"  {Style.DIM('Suggestion:')}")
        print(f"    $ git stash")
        print(f"    $ python {sys.argv[0]} {args.commit or ''}")
        print(f"    $ git stash pop")
        print()
        sys.exit(1)

    # ── Resolve starting commit ──────────────────────────────────
    starting_full = resolve_commit(args.commit or "HEAD")
    starting_info = get_commit_info(starting_full)
    original_ref = get_current_ref()

    log_info(f"Starting from {Style.BOLD(starting_info.short_hash)}  "
             f"{starting_info.message}")
    log_info(f"Timestamp:     {starting_info.timestamp_human}")
    log_info(f"Branch:        {original_ref}")
    print()

    # ── Discover compose group ───────────────────────────────────
    group = find_compose_group(starting_full)

    subheading(f"Compose group — {len(group)} commit{'s' if len(group) != 1 else ''}")

    for i, c in enumerate(group, 1):
        marker = Style.BOLD(f"C{i}")
        print(f"  {marker:<15} {Style.DIM(c.short_hash)}  {c.timestamp_human}")
        print(f"  {'':<15} {c.message}")

    print()

    if len(group) < 2:
        log_warn("Only 1 commit found — nothing to checkpoint-test.")
        print("  A single commit is always self-consistent.")
        print()
        sys.exit(0)

    # ── Run tests ────────────────────────────────────────────────
    subheading("Running test suite at each checkpoint")

    output_dir = Path("temp")
    output_dir.mkdir(exist_ok=True)

    results: list[CheckpointResult] = []
    try:
        for i, commit in enumerate(group, 1):
            result = run_tests_at_checkpoint(commit, i, len(group), output_dir)
            results.append(result)
    except KeyboardInterrupt:
        print()
        log_warn("Interrupted by user.")
    finally:
        log_info(f"Restoring branch: {Style.BOLD(original_ref)}")
        try:
            checkout(original_ref)
        except Exception:
            log_fail(f"Could not restore {original_ref}. "
                     f"Run: git checkout {original_ref}")
        print()

    # ── Report ───────────────────────────────────────────────────
    if results:
        print_report(group, results)

    sys.exit(1 if any(not r.passed for r in results) else 0)


if __name__ == "__main__":
    main()
